<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<TargetEndpoint name="immunisation-history-target">
    <FaultRules>
        <FaultRule name="access_token_invalid">
            <Step>
                <Name>RaiseFault.InvalidAccessToken</Name>
            </Step>
            <Condition>oauthV2.OauthV2.VerifyAccessToken.failed</Condition>
        </FaultRule>
        <FaultRule name="expired_jwt">
            <Condition>(JWT.failed Equals true) And (error.message Equals "The Token has expired: policy(VerifyJWT.FromExternalIdToken)")</Condition>
            <Step>
                <Name>AssignMessage.ExpiredJWTError</Name>
            </Step>
        </FaultRule>
        <FaultRule name="failed_decoding_jwt">
            <Condition>(JWT.failed Equals true) And (fault.name Equals "FailedToDecode")</Condition>
            <Step>
                <Name>AssignMessage.FailedToDecodeJWTError</Name>
            </Step>
        </FaultRule>
        <FaultRule name="missing_invalid-iss">
            <Condition>(JWT.failed Equals true) AND (error.message Equals "Invalid Claim: policy(VerifyJWT.FromExternalIdToken) claim(iss)")</Condition>
            <Step>
                <Name>AssignMessage.MissingOrInvalidIssClaim</Name>
            </Step>
        </FaultRule>
        <FaultRule name="missing_invalid_identity_proofing_level">
            <Condition>(JWT.failed Equals true) AND (error.message Equals "Invalid Claim: policy(VerifyJWT.FromExternalIdToken) claim(identity_proofing_level)")</Condition>
            <Step>
                <Name>AssignMessage.MissingOrInvalidIdentityProofingLevelClaim</Name>
            </Step>
        </FaultRule>
        <FaultRule name="missing_invalid_typ_header">
            <Condition>(JWT.failed Equals true) AND (error.message Equals "Invalid Claim: policy(VerifyJWT.FromExternalIdToken) claim(typ)")</Condition>
            <Step>
                <Name>AssignMessage.MissingOrInvalidTypHeader</Name>
            </Step>
        </FaultRule>
        <FaultRule name="id_token_invalid">
            <Condition>(JWT.failed Equals true) AND (error.message Equals "Invalid token: policy(VerifyJWT.FromExternalIdToken)")</Condition>
            <Step>
                <Name>AssignMessage.FailedToDecodeJWTError</Name>
            </Step>
        </FaultRule>
        <FaultRule name="no_matching_publickey">
            <Condition>(JWT.failed Equals true) AND (error.message Equals "Could not find a matching Public Key: policy(VerifyJWT.FromExternalIdToken)")</Condition>
            <Step>
                <Name>AssignMessage.NoMatchingPublicKey</Name>
            </Step>
        </FaultRule>
    </FaultRules>
    <PreFlow>
        <Request>
            <Step>
                <Name>OauthV2.VerifyAccessToken</Name>
            </Step>
            <!-- If the token was retrieved via token exchange, assign the jwt from the token attributes to the NHSD-User-Identity Header -->
            <Step>
                <Name>AssignMessage.AddUserIdHeader</Name>
                <Condition>accesstoken.grant_type = "urn:ietf:params:oauth:grant-type:token-exchange"</Condition>
            </Step>
            <!-- JWT Header Flow -->
            <Step>
              <Name>AccessEntity.GetApp</Name>
            </Step>
            <Step>
              <Name>ExtractVariables.GetProofingLevel</Name>
            </Step>
            <Step>
                <Name>Javascript.AddClientRPDetailsHeader</Name>
            </Step>
            <Step>
                <Name>Quota</Name>
            </Step>
            <Step>
                <Name>SpikeArrest</Name>
            </Step>
        </Request>
    </PreFlow>
    <HTTPTargetConnection>
        <SSLInfo>
            <Enabled>true</Enabled>
        </SSLInfo>
        <LoadBalancer>
            <Server name="immunisation-history"/>
        </LoadBalancer>
        <Properties>
          <Property name="keepalive.timeout.millis">20000</Property>
        </Properties>
        <Path>/immunisation-history</Path>
    </HTTPTargetConnection>
</TargetEndpoint>