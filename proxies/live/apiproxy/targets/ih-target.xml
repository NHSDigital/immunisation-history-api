<TargetEndpoint name="immunisation-history-target">
  <FaultRules>
    <FaultRule name="access_token_invalid">
      <Step>
        <Name>RaiseFault.InvalidAccessToken</Name>
      </Step>
      <Step>
        <Name>AssignMessage.Errors.CatchAllMessage</Name>
      </Step>
      <Condition>oauthV2.OauthV2.VerifyAccessToken.failed</Condition>
    </FaultRule>
  </FaultRules>
  <PreFlow>
    <Request>
      <Step>
        <Name>OauthV2.VerifyAccessToken</Name>
      </Step>
      <!-- Check NHS User Identity JWT Header Exists-->
      <Step>
        <Name>RaiseFault.MissingNHSDUserIdentityheader</Name>
        <Condition>request.header.NHSD-User-Identity = null</Condition>
      </Step>
      <!--<Step>-->
      <!--    <Name>RaiseFault.MissingOrInvalidIssClaim</Name>-->
      <!-- Get issuer value from KVM instead of hard coded value -->
      <!--    <Condition>(jwt.DecodeJWT.FromNHSDUserIdentityHeader.decoded.claim.iss Is null) or (jwt.DecodeJWT.FromNHSDUserIdentityHeader.decoded.claim.iss NotEquals "https://auth.sandpit.signin.nhs.uk")</Condition>-->
      <!--</Step>-->
      <!--<Step>-->
      <!--    <Name>RaiseFault.MissingOrInvalidTypHeader</Name>-->
      <!--    <Condition>(jwt.DecodeJWT.FromNHSDUserIdentityHeader.decoded.header.typ Is null) Or (Not(jwt.DecodeJWT.FromNHSDUserIdentityHeader.decoded.header.typ EqualsCaseInsensitive "jwt"))</Condition>-->
      <!--</Step>-->
      <!--<Step>-->
      <!--    <Name>RaiseFault.MissingOrInvalidIdentityProofingLevelClaim</Name>-->
      <!--    <Condition>(jwt.DecodeJWT.FromNHSDUserIdentityHeader.decoded.claim.identity_proofing_level Is null) or (Not(jwt.DecodeJWT.FromNHSDUserIdentityHeader.decoded.claim.identity_proofing_level = "P9"))</Condition>-->
      <!--</Step>-->
      <Step>
        <Name>ServiceCallout.NHSLoginGetJWKS</Name>
      </Step>
      <Step>
        <Name>VerifyJWT.FromExternalIdToken</Name>
      </Step>
      <Step>
        <Name>Quota</Name>
      </Step>
      <Step> 
        <Name>SpikeArrest</Name>   
      </Step>
      <!-- Set flow variable 'access-mode' by inspecting the token's scopes.
      First set to least-privilege (application restricted) then look for scopes indicating higher privilege, overwriting as appropriate.
      'scope' is a space-separated string of scopes, determined by the Application's API Product assignments.
      Follow pattern used in AssignMessage.SetAccessModeUserRestricted condition. See Apigee docs for JavaRegex gotchas (uses '.match()' behaviour matching whole string only). -->
      <Step>
        <Name>AssignMessage.SetAccessModeApplicationRestricted</Name>
      </Step>
      <Step>
        <Name>Quota</Name>
      </Step>
      <Step>
        <Name>SpikeArrest</Name>
      </Step>
    </Request>
  </PreFlow>
  <HTTPTargetConnection>
    <SSLInfo>
      <Enabled>true</Enabled>
    </SSLInfo>
    <LoadBalancer>
      <Server name="immunisation-history" />
    </LoadBalancer>
    <Path>/immunisation-history</Path>
  </HTTPTargetConnection>
  <DefaultFaultRule>
    <Step>
        <Name>AssignMessage.Errors.CatchAllMessage</Name>
    </Step>
  </DefaultFaultRule>
</TargetEndpoint>
